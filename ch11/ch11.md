## 11장 DSL 만들기

- 확장 함수
- 중위 호출
- 연산자 오버로딩
- get 메서드에 대한 관례
- 람다를 괄호 밖으로 빼내는 관례
- 수신 객체 지정 람다

DSL 과 일반 APPI 사이에 잘 정의된 일반적인 경계는 없다. 하지만 DSL 에는 존재하는 특징이 한가지 있다. 바로 구조 또는 문법이다.
코틀린 DSL 에서는 보통 람다를 중첩시키거나 메서드 호출을 연쇄시키는 방식으로 구조를 만든다.

#### 11.2.1 수신 객체 지정 람다와 확장 함수 타입
```
fun foo(
	a: StringBuilder.() -> Unit
)
```
위 코드와 같이 수신 객체가 있는 함수 타입의 파라미터를 선언하고, 내부에서 인스턴스를 받아 람다의 수신객체를 넘긴다. 그러면 함수를 호출할 때 this 를 사용하지 않아도 람다를 사용할 수 있다.

### 11.3 invoke 관례를 사용한 더 유연한 블록 중첩
invoke 관례를 사용하면 객체를 함수처럼 호출 할 수 있다.

```
class foo(val a: String) {
	operator fun invoke(s: String) {
		println("${a} ${s}";
	}
}

foo("a")("s") // 함수처럼 호출이 가능
```


### 11.4 실전 코틀린 DSL

코틀린에서는 테스트 코드를 should 를 통해서 언어를 사용하듯이 코드를 작성할 수 있다.
```
"kotlin" should end with "in" // kotlin 은 in 으로 끝나야 한다.
```
