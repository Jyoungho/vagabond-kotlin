# 3장 함수 정의와 호출 

3장에서는 프로그램의 핵심이라 할 수 있는
- 함수 정의와 호출 기능을 코틀린이 어떻게 개선했는지
- 확장 함수와 프로퍼티를 사용해 자바 라이브러리를 코틀린 스타일로 적용하는 방법

## 함수 선언에 대한 새로운 개념
``` kotlin
fun <T> joinToString(
	collection: Collection<T>,
	separator: String,
	prefix: String,
	postfix: String
): String{
....
}
```

``` kotlin
fun <T> Collection<T>.joinToString( //Collection<T>에 대한 확장함수 선언
	separator: String = ", " , //디폴트 값 지정
	prefix: String = "",
	postfix: String = ""
): String{
    val result = StringBuilder(prefix)
    for((index, element) in this.withIndex())   //this는 수신객체
        if(index> 0) result.append(separator)
        result.append(element)
}
result.append(postfix)
return result.toString()
}
```

- 코틀린은 자체 컬렉션 기능을 제공하지 않음
  - 하지만 코틀린은 자바보다 더 많은 기능을 제공함
  - 확장함수 기능 덕분 !
### 이름붙인 인자
  - 인자로 전달한 각 문자열이 어떤 역할을 하는지 구분을 위함
  - 함수에 전달하는 인자 중 일부(또는 전부)의 이름을 명시할 수 있음
### 디폴트 파라미터 값
  - 자바에서는 일부 클래스에서 오버로딩한 메서드가 너무 많아진다는 문제가 존재
  - 코틀린에선 파라미터의 디폴트 값을 지정할 수 있으므로, 위와 같은 상황을 많이 피할 수 있음
### 최상위 함수, 최상위 프로퍼티 
  - 자바에서는 모든 코드를 클래스의 메서드로 작성해야 함. 그래서 어느 한 클래스에 포함시키 어려운 코드가 생기는 등 애매한 경우가 생김
  - 결과적으로 정적 메서드를 모아두는 역할만 담당하며, 특별한 상태나 인스턴스 메서드가 없는 클래스가 생겨남
    - ex) JDK의 Collections 클래스, 또는 Util...클래스
  - 코틀린에서는 이런 무의미한 클래스는 필요 없고, 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 됨.
  - 프로퍼티도 최상위 수준에 놓을 수 있음.
    - public static final필드로 컴파일 하기 위해선, const 변경자를 추가하면 가능함. (원시타입과 String 타입의 프로퍼티만 가능)
  - 확장 함수 
    - 확장함수란, 어떤 클래스의 멤버 메서드인 것 처럼 호출할 수 있지만 그 클래스 밖에 선언된 함수
    - 확장함수를 만들려면, 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면 됨.
    - 클래스 이름은 수신객체 타입(receiver type)
    - 확장 함수가 호출되는 대상이 되는 값(객체)을 수신객체(receiver object)
      ```kotlin
      //String은 수신객체 타입이고, this는 수신책체임
        fun String.lastChar(): Char = this.get(this.length-1)
      ```
    - 확장함수 내부에서는 일반적인 인스턴스의 메서드의 내부에서와 마찬가지로, 수신객체의 메서드나 프로퍼트를 바로 사용 가능. 
    - 캡슐화를 깨진 않는다 -> 클래스 내부에서만 사용할 수 있는 private 멤버나 protected 멤버는 사용 불가
    - 확장함수는 오버라이드 할 수 없음.
      - 확장 함수는 클래스의 일부가 아니고, 클래스 밖에 선언되기 때문
      - 확장함수를 첫 번째 인자가 수신 객체인 정적 자바 메서드로 컴파일 한다는 사실을 기억.
  - 확장 프로퍼티
    - 확장 프로퍼티를 사용하면 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수 있는 API를 추가할 수 있음.
    - 프로퍼티라는 이름으로 불리지만, 상태를 저장할 적절한 방법이 없기 때문에 실제로 확장 프로퍼티는 아무 상태도 가질 수 없음. 
    ```kotlin
      val String.lastChar: Char
      get() = get(length-1)
    ```
    - 확장 프로퍼티도 일반적인 프로퍼티와 같은데, 수신 객체 클래스가 추가됨.
    - 기본 getter 구현을 제공할 수 없으므로, 최소한 게터는 꼭 정의를 해야 함.
    - 


## 컬렉션 처리

### 가변 인자 함수
인자의 개수가 달라질 수 있는 함수 정의

- 자바의 가변길이 인자(varargs)는 메서드를 호출할 때 원하는 개수만큼 값을 인자로 넘기면, 자바 컴파일러가 배열에 그 값을 넣어주는 기능..
- 타입뒤에 ...을 붙이는 대신, 코틀린에서는 파라미터 앞에 vararg 변경자를 붙임.
    ``` kotlin
    fun listOf<T>(vararg values: T): List<T> {...}
    ```
- 이미 배열에 들어있는 원소를 가변 길이 인자로 넘길땐, 코틀린에선 배열을 명시적으로 풀어서 배열의 각 원소가 인자로 전달되게 해야 함. 
- -> 스프레드 연산자, 전달하려는 배열 앞에 *를 붙이기만 하면 된다.
  - ```kotlin
    fun main(args: Array<String>){
        val list = listOf("args: ", *args)
        println(list)
    }
    ```
    
### 값의 쌍 다루기 
중위 호출과 구조 분해 선언

- 중위호출 : 수신 객체와 유일한 메서드 인자 사이에 메서드 이름을 넣는 것
- ```kotlin
    //두개의 값은 동일 
    1.to("one")
    1 to "one"
  ```
- 인자가 하나뿐인 일반 메서드 또는 인자가 하나뿐인 확장함수에 중위 호출을 사용할 수 있음.
- 함수를 중위 호출에 사용하게 허용하고 싶으면 infix변경자를 함수 선언 앞에 추가해야 함. 
- ```kotlin
    infix fun Any.to(other: Any) = Pair(this, other) //infix 변경자 사용
    /**
    * 여러 값을 한꺼번에 반환해야 하는 함수는 구조 분해 선언 구문을 사용하면 쉽게 풀어서
    * 여러 변수를 넣을 수 있다.
    */ 
    val (number, name) = 1 to "one" 
  ```
  
## 문자열과 정규식

### 문자열 나누기
- 자바 String split 메서드는 실제로 정규식임  
- 코틀린에서는 split대신 여러가지 다른 조합의 파라미터를 받는 split 확장함수를 제공
- 정규식을 파라미터로 받는 함수는 String이 아닌 Regex타입의 값을 받음


## 로컬함수와 확장

DRY 원칙을 피하기 위해 긴 메서드를 나누면 메서드 사이의 관계 파악이 어렵다.  
코드 중복을 로컬 함수를 통해 제거해보자

```kotlin
class User(val id: Int, val name: String, val address: String)

fun saveUser(user: User){
    if(user.name.isEmpty()){
        throw IllegalArgumentException("Can't save user ${user.id} : empty Name")
    }
    if(user.address.isEmpty()){
        throw IllegalArgumentException("Can't save user ${user.id} : empty Address")
    }
    //user DB 저장 
}
```

```kotlin
class User(val id: Int, val name: String, val address: String)

fun saveUser(user: User){
    fun validate(value: String, fieldName: String){
        if(value.isEmpty()){
            throw IllegalArgumentException("Can't save user ${user.id} : empty $fieldName")
        }    
    }
    
    validate(user.name, "Name")
    validate(user.address, "Address")
    //user DB 저장 
}
```

- 로컬 함수를 통해 코드 중복을 줄였다
- 로컬 함수는 자신이 속한 바깥 함수의 파라미터와 변수를 사용할 수 있다. 