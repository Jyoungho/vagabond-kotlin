# 4장 클래스, 객체, 인터페이스 

4장에서는 
- 코틀린의 클래스와 인터페이스가 자바의 클래스, 인터페이스와 어떻게 다른지
- 중첩 클래스
- 생성자
- data class, 위임
- object 키워드

## 클래스 계층
### 인터페이스
- 코틀린 인터페이스 안에는 추상 메서드뿐 아니라 구현이 있는 메서드도 정의 가능. (자바 8의 디폴트 메서드)
- 다만, 아무런 필드값도 들어갈 수 없음. 
- 클래스 확장과 구현 시 extends와 implements 대신 : 키워드를 사용.
- 자바와 마찬가지로 인터페이스는 개수제한 없이 구현할 수 있으며, 클래스는 하나만 확장 가능.
- override 변경자를 꼭 사용해야 한다.
- 동일한 메서드가 있는 인터페이스를 중복 구현할 경우 어느쪽도 선택되지 않는다. (대체할 오버라이딩 메서드 직접 제공해야 함)

### 상속 제어 변경자
- 기본적으로 final 
- 상속을 허용하려면 클래스, 메서드 프로퍼티 앞에 open 변경자를 붙여야 함.
- 오버라이드하는 경우 기본적으로 열려있으며, 하위 클래스에서 오버라이드 하지 못하게 하려면 final을 붙여야 함.
- 클래스를 abstract 선언 할 수 있음. 추상 멤버는 항상 열려있음(open)

### 가시성 변경자
코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어  
어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현 변경가능  
자바가 package를 가시성 컨트롤을 위해 사용하는 것과 달리, 코틀린에선 단순히 코드를 정돈하기 위해 사용함.


- public, protected, private, internal 
- 기본 가시성은(아무런 변경자도 없는 경우) public
- public
  - 클래스 멤버: 모든 곳에서 볼 수 있음 
  - 최상위 선언: 모든 곳에서 볼 수 있음
- internal
  - 클래스 멤버: 같은 모듈 안에서만 볼 수 있음
  - 최상위 선언: 같은 모듈 안에서만 볼 수 있음
  - 자바엔 없음. 모듈 내부에서만 가시적이라는 뜻으로 모듈이란 같이 컴파일되는 코틀린 파일 집합을 뜻함
  - 자바에선 지원되지 않는 변경자 이므로, 바이트 코드상으론 public이 됨.
- protected 
  - 클래스 멤버 : 하위 클래스 안에서만 볼 수 있음
  - 최상위 선언 : 최상위 선언에 적용할 수 없ㅇ므
- private
  - 클래스 멤버 : 같은 클래스 안에서만 볼 수 있음
  - 최상위 선언 : 같은 파일 안에서만 볼 수 있음 

### 중첩 클래스
코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없음
- 코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같음.
- 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 inner 변경자를 붙여야 함.
- inner 클래스에서 외부 클래스를 접근하기 위해선 this@Outer을 사용함
```kotlin
class Button: View{
    override fun getCurrentState(): State = ButtonState()
    override fun restoreState(state: State){/*...*/}
    class ButtonSate: State{/*...*/} //이 클래스는 자바의 정적 중첩 클래스와 대응함.
}
```

### 봉인된 클래스
상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있음.  
- sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 함.
```kotlin
interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr

fun eval(e: Expr): Int =
    when (e) {
        is Num -> e.value
        is Sum -> eval(e.right) + eval(e.left)
        else -> // "else" 분기가 꼭 있어야 한다. 
            throw IllegalArgumentException("Unknown expression")
    }
```

## 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언
- 자바에서와 마찬가지로 코틀린도 생성자를 하나 이상 선언할 수 있음  
- 주 생성자와 부 생성자를 구분함 
  - 주 생성자 
    - 보통 클래스를 초기화 할 때 주로 사용하는 간략한 생성자. 클래스 본문 밖에서 정의
  - 부 생성자
    - 클래스 본문안에서 정의 
- 초기화 블록을 통해 초기화 로직 추가 가능

### 클래스 초기화
```kotlin
//위와 아래는 동일한 목적을 달성한다
class User(val nickName: String)

class User constructor(_nickName: String){
    val nickName: String
    init {
        nickName = _nickName
    }
  
  //프로퍼티를 생성자 파라미터로 초기화
  //별다른 어노테이션이나 가시성 수식어가 없다면 constructor 생략 가능
class User(_nickName: String){
    val nickName = _nickName
}  
}

```
- 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 주 생성자라고 부름.
- 주 생성자는 생성자 파라미터를 지정
- 그 생성자 파라미터에 의해 초기화 되는 프로퍼티를 정의
- constructor 키워드는 주 생성자나 부 생성자 정의를 시작할 때 사용 
- init 키워드는 초기화 블록을 시작함
- 초기화 블록에는 클래스의 객체가 만들어질 때(인스턴스화 될 때) 실행될 초기화 코드가 들어감
- 주 생성자는 제한적이기 때문에 별도의 코드를 포함할 수 없으므로 초기화 블록 필요
- 여러 초기화 블록 선언 가능
- 프로퍼티를 초기화 하는 식이나 초기화 블록 안에서만 주 생성자의 파라미터를 참조할 수 있음
- 모든 생성자 파라미터에 디폴트 값을 지정하면 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어줌.
- 슈퍼클래스가 있는 자식 클래스의 경우, 슈퍼 클래스의 주 생성자 또한 초기화되어야 함.


### 부 생성자
여러가지 방법으로 인스턴스를 초기화할 방법이 필요한 경우, 부 생성자를 사용함
- 자바와 마찬가지로, 자기 자신의 생성자 호출을 위해서는 this()를, 슈퍼 클래스의 생성자 호출을 위해서는 super() 사용함.


### 인터페이스의 추상 프로퍼티와 구현
- 인터페이스에서 상태는 가질 수 없지만, 추상 프로퍼티 정의는 가능함.
- 인터페이스의 추상 프로퍼티는 지원필드나 게터등의 정보가 없으므로, 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티 등을 만들어야 함.
```kotlin
interface User {
		val nickName: String
}

class PrivateUser(override val nickname: String) : User // 주 생성자에 있는 프로퍼티

class SubscribingUser(val email: String) : User {
    override val nickname: String // 커스텀 게터
        get() = email.substringBefore('@')
}

class FacebookUser(val accountId: Int) : User {
    override val nickname = getFacebookName(accountId) // 프로퍼티 초기화 식
}
```

## data class
- 데이터 클래스는 equals(), hashCode(),toString()을 자동으로 생성


## 클래스 위임 
클래스 위임은 by 키워드를 통해 가능함.  
상속을 하지 않고 클래스에 새로운 동작을 추가하기 위해선 주로 데코레이터 패턴을 활용함.  
이를 위해선 동일한 인터페이스를 구현해야하고,관련되지 않은 모든 동작도 하나씩 위임해줘야 함.  
코틀린은 컴파일러의 자동 생성으로 이러한 위임을 간편히 할 수 있도록 제공함 

## object
object 키워드로 객체 선언을 시작할 경우 클래스 선언과 동시에 인스턴스를 생성(싱글톤 보장)  

## 동반 객체
companion 키워드를 가진 클래스를 의미.  
코틀린은 클래스 내부에서 static 메서드를 제공하지 않는데, 그 대신 private 멤버를 접근하기 위해 동반 객체를 사용.  
동반 객체의 멤버를 사용하는 구문은 정적 메서드 호출이나 정적 필드 사용과 유사.
